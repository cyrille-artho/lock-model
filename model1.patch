diff --git a/compile.sh b/compile.sh
index 98e3020..1a48133 100755
--- a/compile.sh
+++ b/compile.sh
@@ -6,4 +6,4 @@ then
 	exit
 fi
 
-javac -classpath ${JPF_HOME}/build/jpf.jar:. *.java */*.java
+javac -Xlint -classpath ${JPF_HOME}/build/jpf.jar:. *.java */*.java
diff --git a/rtems/ChainControl.java b/rtems/ChainControl.java
index d6ed852..325906e 100644
--- a/rtems/ChainControl.java
+++ b/rtems/ChainControl.java
@@ -7,5 +7,8 @@ public class ChainControl{
 		this.next = null;
 		this.prev = null;
 	}
+	public void init(){
+		this.next = null;
+		this.prev = null;
+	}
 }
-
diff --git a/rtems/Mutex.java b/rtems/Mutex.java
index d10e17e..6be921c 100644
--- a/rtems/Mutex.java
+++ b/rtems/Mutex.java
@@ -1,20 +1,23 @@
 package rtems;
-
 import base.Lock;
 import base.Condition;
+import java.util.Comparator;
+import java.util.PriorityQueue;
 
 public class Mutex {
 	int nestCount;
-	Object waitQueue;
-	Object holder;
-	Object orderRec; 
+	PriorityQueue<Object> waitQueue;
+	RTEMSThread holder;
+	//Object orderRec;
+	int priorityBefore; 
 	final Lock parentLock = new /*Reentrant*/Lock();
-   	final Condition cv1  = parentLock.newCondition(); 
+	final Condition cv1  = parentLock.newCondition(); 
+	MyComparator comparator = new MyComparator();
 	public Mutex()
 	{
 		this.nestCount = 0;
 		this.holder = null;
-		this.orderRec = new OrderList();
+		PriorityQueue<RTEMSThread> waitQueue = new PriorityQueue<RTEMSThread>(7, comparator);
 	}
 	public void lock() throws InterruptedException{
 		parentLock.lock();
@@ -22,16 +25,18 @@ public class Mutex {
 		try{
 			if((holder!=null) && (holder!=thisThread))
 			{
-				if(priorityRaiseFilter(thisThread.getPriority()))
+				if(priorityRaiseFilter(thisThread.currentPriority))
 				{
 					//1. Update priority of holder thread
-					updatePriority();
+					updatePriority(thisThread.currentPriority);
 					//2. Re-enqueue holder thread with modified priority if its waiting 
-					renqueue();
+					reEnqueue();
 				}
 				thisThread.state = Thread.State.WAITING;
 				while(!(thisThread.state==Thread.State.RUNNABLE)){
-					cv1.await();
+					this.waitQueue.offer(thisThread);
+					thisThread.wait = waitQueue;
+					cv1.wait();
 				}
 			}
 			//if code reaches here it means it has the potential to acquire the mutex
@@ -39,9 +44,10 @@ public class Mutex {
 			{
 				holder = thisThread;
 				nestCount = 1;
-				orderRec.priorityBefore = thisThread.currentPriority;
+				this.priorityBefore = thisThread.currentPriority;
 				thisThread.mutexOrderList.add(0, this);
 				// FIXME: Really prepend? Use LinkedList if prepend is common
+				//Also have to chain it to threads lockMutex chain
 			}
 			else
 			{
@@ -49,25 +55,91 @@ public class Mutex {
 				//how should we prepend here???Doubt the orderRec as it is already present in thisThread.mutexList
 			}
 		  }finally{
-		  	parentLock.unlock();
+			parentLock.unlock();
 		  }
 
 	}
 	public void unlock() throws InterruptedException{
+		Object topMutex=null;
+		RTEMSThread thisThread = (RTEMSThread)Thread.currentThread();
+		RTEMSThread candidateThr;
+		int stepdownPri;
 		parentLock.lock();
 		//proper step down of priority.
 		//remove eligible candidate thread from this.waitQueue
 		//set the state of that thread to Params.RUNNABLE
 		//signalAll()
 		//unlockparentLock.lock()
+		try{
+			//1.Assertion Check
+			topMutex = thisThread.mutexOrderList.get(0);
+			if(topMutex!=this){
+				//assertion error for strict order mutexes
+			}
+			//Not handling the nesting case right now.
+			//2. Remove top element from mutexOrderList
+			//mutexOrderList is acting as chaincontrol structure for us.
+			//Right now avoiding complications
+			topMutex = thisThread.mutexOrderList.remove(0);
+			//3. Initialize the mutex orderList
+			//this.orderRec.node.init();
+			//4. stepdown of priority for this thread
+			stepdownPri = this.priorityBefore;
+
+			thisThread.setPriority(stepdownPri);
+			//5. Re-enqueue if thread is waiting
+			reEnqueue();
+			holder = null;
+			candidateThr = (RTEMSThread)waitQueue.poll();
+			if(candidateThr != null){
+				candidateThr.state = Thread.State.RUNNABLE;
+				//Logically only candidate will go through lock and rest will again get queued up
+				cv1.notifyAll();
+			}
+
+		}finally{
+			parentLock.unlock();
+		}
 	}
-	public void updatePriority()
-	{
 
+	public boolean priorityRaiseFilter(int priority){
+		int holderPriority = holder.getPriority();
+		if(priority < holderPriority){
+			return true;
+		}
+		return false;
 	}
 
-	public void renqueue()
+	public void updatePriority(int priority)
+	{
+		holder.currentPriority = priority;
+		holder.setPriority(priority);
+	}
+
+	public void updateRecPriority(int priority)
+	{
+
+	}
+	
+	public void reEnqueue()
 	{
 		//if holder thread is waiting on someother mutex reenqueue that thread with updated priority.
+		PriorityQueue<Object> pqueue;
+		if(holder.wait!=null)
+		{
+			pqueue = holder.wait;
+			pqueue.remove(holder);
+			pqueue.offer(holder);
+		}
 	}
 }
+
+class MyComparator implements Comparator<RTEMSThread>
+{
+	@Override
+	public int compare(RTEMSThread t1, RTEMSThread t2)
+	{
+		return t1.getPriority() - t2.getPriority();
+	}
+}
+
diff --git a/rtems/RTEMSThread.java b/rtems/RTEMSThread.java
index ec70984..fe0a92d 100644
--- a/rtems/RTEMSThread.java
+++ b/rtems/RTEMSThread.java
@@ -1,13 +1,13 @@
 package rtems;
-
+import java.util.PriorityQueue;
 import java.util.ArrayList;
 
 public class RTEMSThread extends Thread {
   // TODO: add extra priority field etc.
-	Object wait;
+	PriorityQueue<Object> wait;
 	int resourceCount;
 	Thread.State state;
-	Object lockMutex;
+	//Object lockMutex; mutexOrderList will suffice
 	int currentPriority;
 	int realPriority;
 	ArrayList<Mutex> mutexOrderList;  //it is a linkedList which stores acquired mutex objects in LIFO order.  
@@ -15,6 +15,8 @@ public class RTEMSThread extends Thread {
 		this();
 		this.currentPriority = this.realPriority = priority;
 		this.state = state;
+		//this.lockMutex = new ChainControl();
+		PriorityQueue<RTEMSThread> wait = null;
 	}
 
 	public RTEMSThread() {
@@ -22,4 +24,5 @@ public class RTEMSThread extends Thread {
 		this.mutexOrderList = new ArrayList<Mutex>();
 		state = Thread.State.NEW;
 	}
+
 }
